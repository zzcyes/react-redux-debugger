{"version":3,"file":"redux.mjs","sources":["../src/utils/formatProdErrorMessage.ts","../src/utils/symbol-observable.ts","../src/utils/actionTypes.ts","../src/utils/isPlainObject.ts","../src/createStore.ts","../src/combineReducers.ts","../src/bindActionCreators.ts","../src/compose.ts","../src/applyMiddleware.ts"],"sourcesContent":["/**\r\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\r\n *\r\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\r\n * during build.\r\n * @param {number} code\r\n */\r\nfunction formatProdErrorMessage(code: number) {\r\n  return (\r\n    `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or ` +\r\n    'use the non-minified dev environment for full errors. '\r\n  )\r\n}\r\n\r\nexport default formatProdErrorMessage\r\n","declare global {\r\n  interface SymbolConstructor {\r\n    readonly observable: symbol\r\n  }\r\n}\r\n\r\nconst $$observable = /* #__PURE__ */ (() =>\r\n  (typeof Symbol === 'function' && Symbol.observable) || '@@observable')()\r\n\r\nexport default $$observable\r\n","/**\r\n * These are private action types reserved by Redux.\r\n * For any unknown actions, you must return the current state.\r\n * If the current state is undefined, you must return the initial state.\r\n * Do not reference these action types directly in your code.\r\n */\r\n\r\nconst randomString = () =>\r\n  Math.random().toString(36).substring(7).split('').join('.')\r\n\r\nconst ActionTypes = {\r\n  INIT: `@@redux/INIT${/* #__PURE__ */ randomString()}`,\r\n  REPLACE: `@@redux/REPLACE${/* #__PURE__ */ randomString()}`,\r\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\r\n}\r\n\r\nexport default ActionTypes\r\n","/**\r\n * @param obj The object to inspect.\r\n * @returns True if the argument appears to be a plain object.\r\n */\r\nexport default function isPlainObject(obj: any): boolean {\r\n  if (typeof obj !== 'object' || obj === null) return false\r\n\r\n  let proto = obj\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(obj) === proto\r\n}\r\n","import $$observable from './utils/symbol-observable'\r\n\r\nimport {\r\n  Store,\r\n  PreloadedState,\r\n  StoreEnhancer,\r\n  Dispatch,\r\n  Observer,\r\n  ExtendState\r\n} from './types/store'\r\nimport { Action } from './types/actions'\r\nimport { Reducer } from './types/reducers'\r\nimport ActionTypes from './utils/actionTypes'\r\nimport isPlainObject from './utils/isPlainObject'\r\nimport { kindOf } from './utils/kindOf'\r\n\r\n/**\r\n * Creates a Redux store that holds the state tree.\r\n * The only way to change the data in the store is to call `dispatch()` on it.\r\n *\r\n * There should only be a single store in your app. To specify how different\r\n * parts of the state tree respond to actions, you may combine several reducers\r\n * into a single reducer function by using `combineReducers`.\r\n *\r\n * @param reducer A function that returns the next state tree, given\r\n * the current state tree and the action to handle.\r\n *\r\n * @param preloadedState The initial state. You may optionally specify it\r\n * to hydrate the state from the server in universal apps, or to restore a\r\n * previously serialized user session.\r\n * If you use `combineReducers` to produce the root reducer function, this must be\r\n * an object with the same shape as `combineReducers` keys.\r\n *\r\n * @param enhancer The store enhancer. You may optionally specify it\r\n * to enhance the store with third-party capabilities such as middleware,\r\n * time travel, persistence, etc. The only store enhancer that ships with Redux\r\n * is `applyMiddleware()`.\r\n *\r\n * @returns A Redux store that lets you read the state, dispatch actions\r\n * and subscribe to changes.\r\n */\r\nexport default function createStore<\r\n  S,\r\n  A extends Action,\r\n  Ext = {},\r\n  StateExt = never\r\n>(\r\n  reducer: Reducer<S, A>,\r\n  enhancer?: StoreEnhancer<Ext, StateExt>\r\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\r\nexport default function createStore<\r\n  S,\r\n  A extends Action,\r\n  Ext = {},\r\n  StateExt = never\r\n>(\r\n  reducer: Reducer<S, A>,\r\n  preloadedState?: PreloadedState<S>,\r\n  enhancer?: StoreEnhancer<Ext, StateExt>\r\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\r\nexport default function createStore<\r\n  S,\r\n  A extends Action,\r\n  Ext = {},\r\n  StateExt = never\r\n>(\r\n  reducer: Reducer<S, A>,\r\n  preloadedState?: PreloadedState<S> | StoreEnhancer<Ext, StateExt>,\r\n  enhancer?: StoreEnhancer<Ext, StateExt>\r\n): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext {\r\n  if (\r\n    (typeof preloadedState === 'function' && typeof enhancer === 'function') ||\r\n    (typeof enhancer === 'function' && typeof arguments[3] === 'function')\r\n  ) {\r\n    throw new Error(\r\n      'It looks like you are passing several store enhancers to ' +\r\n        'createStore(). This is not supported. Instead, compose them ' +\r\n        'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.'\r\n    )\r\n  }\r\n\r\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n    enhancer = preloadedState as StoreEnhancer<Ext, StateExt>\r\n    preloadedState = undefined\r\n  }\r\n\r\n  if (typeof enhancer !== 'undefined') {\r\n    if (typeof enhancer !== 'function') {\r\n      throw new Error(\r\n        `Expected the enhancer to be a function. Instead, received: '${kindOf(\r\n          enhancer\r\n        )}'`\r\n      )\r\n    }\r\n\r\n    return enhancer(createStore)(\r\n      reducer,\r\n      preloadedState as PreloadedState<S>\r\n    ) as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\r\n  }\r\n\r\n  if (typeof reducer !== 'function') {\r\n    throw new Error(\r\n      `Expected the root reducer to be a function. Instead, received: '${kindOf(\r\n        reducer\r\n      )}'`\r\n    )\r\n  }\r\n\r\n  let currentReducer = reducer\r\n  let currentState = preloadedState as S\r\n  let currentListeners: (() => void)[] | null = []\r\n  let nextListeners = currentListeners\r\n  let isDispatching = false\r\n\r\n  /**\r\n   * This makes a shallow copy of currentListeners so we can use\r\n   * nextListeners as a temporary list while dispatching.\r\n   *\r\n   * This prevents any bugs around consumers calling\r\n   * subscribe/unsubscribe in the middle of a dispatch.\r\n   */\r\n  function ensureCanMutateNextListeners() {\r\n    if (nextListeners === currentListeners) {\r\n      nextListeners = currentListeners.slice()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the state tree managed by the store.\r\n   *\r\n   * @returns The current state tree of your application.\r\n   */\r\n  function getState(): S {\r\n    if (isDispatching) {\r\n      throw new Error(\r\n        'You may not call store.getState() while the reducer is executing. ' +\r\n          'The reducer has already received the state as an argument. ' +\r\n          'Pass it down from the top reducer instead of reading it from the store.'\r\n      )\r\n    }\r\n\r\n    return currentState as S\r\n  }\r\n\r\n  /**\r\n   * Adds a change listener. It will be called any time an action is dispatched,\r\n   * and some part of the state tree may potentially have changed. You may then\r\n   * call `getState()` to read the current state tree inside the callback.\r\n   *\r\n   * You may call `dispatch()` from a change listener, with the following\r\n   * caveats:\r\n   *\r\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\r\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\r\n   * will not have any effect on the `dispatch()` that is currently in progress.\r\n   * However, the next `dispatch()` call, whether nested or not, will use a more\r\n   * recent snapshot of the subscription list.\r\n   *\r\n   * 2. The listener should not expect to see all state changes, as the state\r\n   * might have been updated multiple times during a nested `dispatch()` before\r\n   * the listener is called. It is, however, guaranteed that all subscribers\r\n   * registered before the `dispatch()` started will be called with the latest\r\n   * state by the time it exits.\r\n   *\r\n   * @param listener A callback to be invoked on every dispatch.\r\n   * @returns A function to remove this change listener.\r\n   */\r\n  function subscribe(listener: () => void) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error(\r\n        `Expected the listener to be a function. Instead, received: '${kindOf(\r\n          listener\r\n        )}'`\r\n      )\r\n    }\r\n\r\n    if (isDispatching) {\r\n      throw new Error(\r\n        'You may not call store.subscribe() while the reducer is executing. ' +\r\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\r\n          'component and invoke store.getState() in the callback to access the latest state. ' +\r\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\r\n      )\r\n    }\r\n\r\n    let isSubscribed = true\r\n\r\n    ensureCanMutateNextListeners()\r\n    nextListeners.push(listener)\r\n\r\n    return function unsubscribe() {\r\n      if (!isSubscribed) {\r\n        return\r\n      }\r\n\r\n      if (isDispatching) {\r\n        throw new Error(\r\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\r\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\r\n        )\r\n      }\r\n\r\n      isSubscribed = false\r\n\r\n      ensureCanMutateNextListeners()\r\n      const index = nextListeners.indexOf(listener)\r\n      nextListeners.splice(index, 1)\r\n      currentListeners = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches an action. It is the only way to trigger a state change.\r\n   *\r\n   * The `reducer` function, used to create the store, will be called with the\r\n   * current state tree and the given `action`. Its return value will\r\n   * be considered the **next** state of the tree, and the change listeners\r\n   * will be notified.\r\n   *\r\n   * The base implementation only supports plain object actions. If you want to\r\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\r\n   * wrap your store creating function into the corresponding middleware. For\r\n   * example, see the documentation for the `redux-thunk` package. Even the\r\n   * middleware will eventually dispatch plain object actions using this method.\r\n   *\r\n   * @param action A plain object representing “what changed”. It is\r\n   * a good idea to keep actions serializable so you can record and replay user\r\n   * sessions, or use the time travelling `redux-devtools`. An action must have\r\n   * a `type` property which may not be `undefined`. It is a good idea to use\r\n   * string constants for action types.\r\n   *\r\n   * @returns For convenience, the same action object you dispatched.\r\n   *\r\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\r\n   * return something else (for example, a Promise you can await).\r\n   */\r\n  function dispatch(action: A) {\r\n    if (!isPlainObject(action)) {\r\n      throw new Error(\r\n        `Actions must be plain objects. Instead, the actual type was: '${kindOf(\r\n          action\r\n        )}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`\r\n      )\r\n    }\r\n\r\n    if (typeof action.type === 'undefined') {\r\n      throw new Error(\r\n        'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.'\r\n      )\r\n    }\r\n\r\n    if (isDispatching) {\r\n      throw new Error('Reducers may not dispatch actions.')\r\n    }\r\n\r\n    try {\r\n      isDispatching = true\r\n      currentState = currentReducer(currentState, action)\r\n    } finally {\r\n      isDispatching = false\r\n    }\r\n\r\n    const listeners = (currentListeners = nextListeners)\r\n    for (let i = 0; i < listeners.length; i++) {\r\n      const listener = listeners[i]\r\n      listener()\r\n    }\r\n\r\n    return action\r\n  }\r\n\r\n  /**\r\n   * Replaces the reducer currently used by the store to calculate the state.\r\n   *\r\n   * You might need this if your app implements code splitting and you want to\r\n   * load some of the reducers dynamically. You might also need this if you\r\n   * implement a hot reloading mechanism for Redux.\r\n   *\r\n   * @param nextReducer The reducer for the store to use instead.\r\n   * @returns The same store instance with a new reducer in place.\r\n   */\r\n  function replaceReducer<NewState, NewActions extends A>(\r\n    nextReducer: Reducer<NewState, NewActions>\r\n  ): Store<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext {\r\n    if (typeof nextReducer !== 'function') {\r\n      throw new Error(\r\n        `Expected the nextReducer to be a function. Instead, received: '${kindOf(\r\n          nextReducer\r\n        )}`\r\n      )\r\n    }\r\n\r\n    // TODO: do this more elegantly\r\n    ;(currentReducer as unknown as Reducer<NewState, NewActions>) = nextReducer\r\n\r\n    // This action has a similar effect to ActionTypes.INIT.\r\n    // Any reducers that existed in both the new and old rootReducer\r\n    // will receive the previous state. This effectively populates\r\n    // the new state tree with any relevant data from the old one.\r\n    dispatch({ type: ActionTypes.REPLACE } as A)\r\n    // change the type of the store by casting it to the new store\r\n    return store as unknown as Store<\r\n      ExtendState<NewState, StateExt>,\r\n      NewActions,\r\n      StateExt,\r\n      Ext\r\n    > &\r\n      Ext\r\n  }\r\n\r\n  /**\r\n   * Interoperability point for observable/reactive libraries.\r\n   * @returns A minimal observable of state changes.\r\n   * For more information, see the observable proposal:\r\n   * https://github.com/tc39/proposal-observable\r\n   */\r\n  function observable() {\r\n    const outerSubscribe = subscribe\r\n    return {\r\n      /**\r\n       * The minimal observable subscription method.\r\n       * @param observer Any object that can be used as an observer.\r\n       * The observer object should have a `next` method.\r\n       * @returns An object with an `unsubscribe` method that can\r\n       * be used to unsubscribe the observable from the store, and prevent further\r\n       * emission of values from the observable.\r\n       */\r\n      subscribe(observer: unknown) {\r\n        if (typeof observer !== 'object' || observer === null) {\r\n          throw new TypeError(\r\n            `Expected the observer to be an object. Instead, received: '${kindOf(\r\n              observer\r\n            )}'`\r\n          )\r\n        }\r\n\r\n        function observeState() {\r\n          const observerAsObserver = observer as Observer<S>\r\n          if (observerAsObserver.next) {\r\n            observerAsObserver.next(getState())\r\n          }\r\n        }\r\n\r\n        observeState()\r\n        const unsubscribe = outerSubscribe(observeState)\r\n        return { unsubscribe }\r\n      },\r\n\r\n      [$$observable]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n\r\n  // When a store is created, an \"INIT\" action is dispatched so that every\r\n  // reducer returns their initial state. This effectively populates\r\n  // the initial state tree.\r\n  dispatch({ type: ActionTypes.INIT } as A)\r\n\r\n  const store = {\r\n    dispatch: dispatch as Dispatch<A>,\r\n    subscribe,\r\n    getState,\r\n    replaceReducer,\r\n    [$$observable]: observable\r\n  } as unknown as Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\r\n  return store\r\n}\r\n","import { AnyAction, Action } from './types/actions'\r\nimport {\r\n  ActionFromReducersMapObject,\r\n  Reducer,\r\n  ReducersMapObject,\r\n  StateFromReducersMapObject\r\n} from './types/reducers'\r\nimport { CombinedState } from './types/store'\r\n\r\nimport ActionTypes from './utils/actionTypes'\r\nimport isPlainObject from './utils/isPlainObject'\r\nimport warning from './utils/warning'\r\nimport { kindOf } from './utils/kindOf'\r\n\r\nfunction getUnexpectedStateShapeWarningMessage(\r\n  inputState: object,\r\n  reducers: ReducersMapObject,\r\n  action: Action,\r\n  unexpectedKeyCache: { [key: string]: true }\r\n) {\r\n  const reducerKeys = Object.keys(reducers)\r\n  const argumentName =\r\n    action && action.type === ActionTypes.INIT\r\n      ? 'preloadedState argument passed to createStore'\r\n      : 'previous state received by the reducer'\r\n\r\n  if (reducerKeys.length === 0) {\r\n    return (\r\n      'Store does not have a valid reducer. Make sure the argument passed ' +\r\n      'to combineReducers is an object whose values are reducers.'\r\n    )\r\n  }\r\n\r\n  if (!isPlainObject(inputState)) {\r\n    return (\r\n      `The ${argumentName} has unexpected type of \"${kindOf(\r\n        inputState\r\n      )}\". Expected argument to be an object with the following ` +\r\n      `keys: \"${reducerKeys.join('\", \"')}\"`\r\n    )\r\n  }\r\n\r\n  const unexpectedKeys = Object.keys(inputState).filter(\r\n    key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\r\n  )\r\n\r\n  unexpectedKeys.forEach(key => {\r\n    unexpectedKeyCache[key] = true\r\n  })\r\n\r\n  if (action && action.type === ActionTypes.REPLACE) return\r\n\r\n  if (unexpectedKeys.length > 0) {\r\n    return (\r\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\r\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\r\n      `Expected to find one of the known reducer keys instead: ` +\r\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\r\n    )\r\n  }\r\n}\r\n\r\nfunction assertReducerShape(reducers: ReducersMapObject) {\r\n  Object.keys(reducers).forEach(key => {\r\n    const reducer = reducers[key]\r\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\r\n\r\n    if (typeof initialState === 'undefined') {\r\n      throw new Error(\r\n        `The slice reducer for key \"${key}\" returned undefined during initialization. ` +\r\n          `If the state passed to the reducer is undefined, you must ` +\r\n          `explicitly return the initial state. The initial state may ` +\r\n          `not be undefined. If you don't want to set a value for this reducer, ` +\r\n          `you can use null instead of undefined.`\r\n      )\r\n    }\r\n\r\n    if (\r\n      typeof reducer(undefined, {\r\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\r\n      }) === 'undefined'\r\n    ) {\r\n      throw new Error(\r\n        `The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` +\r\n          `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` +\r\n          `namespace. They are considered private. Instead, you must return the ` +\r\n          `current state for any unknown actions, unless it is undefined, ` +\r\n          `in which case you must return the initial state, regardless of the ` +\r\n          `action type. The initial state may not be undefined, but can be null.`\r\n      )\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Turns an object whose values are different reducer functions, into a single\r\n * reducer function. It will call every child reducer, and gather their results\r\n * into a single state object, whose keys correspond to the keys of the passed\r\n * reducer functions.\r\n *\r\n * @template S Combined state object type.\r\n *\r\n * @param reducers An object whose values correspond to different reducer\r\n *   functions that need to be combined into one. One handy way to obtain it\r\n *   is to use ES6 `import * as reducers` syntax. The reducers may never\r\n *   return undefined for any action. Instead, they should return their\r\n *   initial state if the state passed to them was undefined, and the current\r\n *   state for any unrecognized action.\r\n *\r\n * @returns A reducer function that invokes every reducer inside the passed\r\n *   object, and builds a state object with the same shape.\r\n */\r\nexport default function combineReducers<S>(\r\n  reducers: ReducersMapObject<S, any>\r\n): Reducer<CombinedState<S>>\r\nexport default function combineReducers<S, A extends Action = AnyAction>(\r\n  reducers: ReducersMapObject<S, A>\r\n): Reducer<CombinedState<S>, A>\r\nexport default function combineReducers<M extends ReducersMapObject>(\r\n  reducers: M\r\n): Reducer<\r\n  CombinedState<StateFromReducersMapObject<M>>,\r\n  ActionFromReducersMapObject<M>\r\n>\r\nexport default function combineReducers(reducers: ReducersMapObject) {\r\n  const reducerKeys = Object.keys(reducers)\r\n  const finalReducers: ReducersMapObject = {}\r\n  for (let i = 0; i < reducerKeys.length; i++) {\r\n    const key = reducerKeys[i]\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (typeof reducers[key] === 'undefined') {\r\n        warning(`No reducer provided for key \"${key}\"`)\r\n      }\r\n    }\r\n\r\n    if (typeof reducers[key] === 'function') {\r\n      finalReducers[key] = reducers[key]\r\n    }\r\n  }\r\n  const finalReducerKeys = Object.keys(finalReducers)\r\n\r\n  // This is used to make sure we don't warn about the same\r\n  // keys multiple times.\r\n  let unexpectedKeyCache: { [key: string]: true }\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    unexpectedKeyCache = {}\r\n  }\r\n\r\n  let shapeAssertionError: unknown\r\n  try {\r\n    assertReducerShape(finalReducers)\r\n  } catch (e) {\r\n    shapeAssertionError = e\r\n  }\r\n\r\n  return function combination(\r\n    state: StateFromReducersMapObject<typeof reducers> = {},\r\n    action: AnyAction\r\n  ) {\r\n    if (shapeAssertionError) {\r\n      throw shapeAssertionError\r\n    }\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\r\n        state,\r\n        finalReducers,\r\n        action,\r\n        unexpectedKeyCache\r\n      )\r\n      if (warningMessage) {\r\n        warning(warningMessage)\r\n      }\r\n    }\r\n\r\n    let hasChanged = false\r\n    const nextState: StateFromReducersMapObject<typeof reducers> = {}\r\n    for (let i = 0; i < finalReducerKeys.length; i++) {\r\n      const key = finalReducerKeys[i]\r\n      const reducer = finalReducers[key]\r\n      const previousStateForKey = state[key]\r\n      const nextStateForKey = reducer(previousStateForKey, action)\r\n      if (typeof nextStateForKey === 'undefined') {\r\n        const actionType = action && action.type\r\n        throw new Error(\r\n          `When called with an action of type ${\r\n            actionType ? `\"${String(actionType)}\"` : '(unknown type)'\r\n          }, the slice reducer for key \"${key}\" returned undefined. ` +\r\n            `To ignore an action, you must explicitly return the previous state. ` +\r\n            `If you want this reducer to hold no value, you can return null instead of undefined.`\r\n        )\r\n      }\r\n      nextState[key] = nextStateForKey\r\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\r\n    }\r\n    hasChanged =\r\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\r\n    return hasChanged ? nextState : state\r\n  }\r\n}\r\n","import { Dispatch } from './types/store'\r\nimport {\r\n  AnyAction,\r\n  ActionCreator,\r\n  ActionCreatorsMapObject\r\n} from './types/actions'\r\nimport { kindOf } from './utils/kindOf'\r\n\r\nfunction bindActionCreator<A extends AnyAction = AnyAction>(\r\n  actionCreator: ActionCreator<A>,\r\n  dispatch: Dispatch\r\n) {\r\n  return function (this: any, ...args: any[]) {\r\n    return dispatch(actionCreator.apply(this, args))\r\n  }\r\n}\r\n\r\n/**\r\n * Turns an object whose values are action creators, into an object with the\r\n * same keys, but with every function wrapped into a `dispatch` call so they\r\n * may be invoked directly. This is just a convenience method, as you can call\r\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\r\n *\r\n * For convenience, you can also pass an action creator as the first argument,\r\n * and get a dispatch wrapped function in return.\r\n *\r\n * @param actionCreators An object whose values are action\r\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\r\n * syntax. You may also pass a single function.\r\n *\r\n * @param dispatch The `dispatch` function available on your Redux\r\n * store.\r\n *\r\n * @returns The object mimicking the original object, but with\r\n * every action creator wrapped into the `dispatch` call. If you passed a\r\n * function as `actionCreators`, the return value will also be a single\r\n * function.\r\n */\r\nexport default function bindActionCreators<A, C extends ActionCreator<A>>(\r\n  actionCreator: C,\r\n  dispatch: Dispatch\r\n): C\r\n\r\nexport default function bindActionCreators<\r\n  A extends ActionCreator<any>,\r\n  B extends ActionCreator<any>\r\n>(actionCreator: A, dispatch: Dispatch): B\r\n\r\nexport default function bindActionCreators<\r\n  A,\r\n  M extends ActionCreatorsMapObject<A>\r\n>(actionCreators: M, dispatch: Dispatch): M\r\nexport default function bindActionCreators<\r\n  M extends ActionCreatorsMapObject,\r\n  N extends ActionCreatorsMapObject\r\n>(actionCreators: M, dispatch: Dispatch): N\r\n\r\nexport default function bindActionCreators(\r\n  actionCreators: ActionCreator<any> | ActionCreatorsMapObject,\r\n  dispatch: Dispatch\r\n) {\r\n  if (typeof actionCreators === 'function') {\r\n    return bindActionCreator(actionCreators, dispatch)\r\n  }\r\n\r\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\r\n    throw new Error(\r\n      `bindActionCreators expected an object or a function, but instead received: '${kindOf(\r\n        actionCreators\r\n      )}'. ` +\r\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\r\n    )\r\n  }\r\n\r\n  const boundActionCreators: ActionCreatorsMapObject = {}\r\n  for (const key in actionCreators) {\r\n    const actionCreator = actionCreators[key]\r\n    if (typeof actionCreator === 'function') {\r\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\r\n    }\r\n  }\r\n  return boundActionCreators\r\n}\r\n","type Func<T extends any[], R> = (...a: T) => R\r\n\r\n/**\r\n * Composes single-argument functions from right to left. The rightmost\r\n * function can take multiple arguments as it provides the signature for the\r\n * resulting composite function.\r\n *\r\n * @param funcs The functions to compose.\r\n * @returns A function obtained by composing the argument functions from right\r\n *   to left. For example, `compose(f, g, h)` is identical to doing\r\n *   `(...args) => f(g(h(...args)))`.\r\n */\r\nexport default function compose(): <R>(a: R) => R\r\n\r\nexport default function compose<F extends Function>(f: F): F\r\n\r\n/* two functions */\r\nexport default function compose<A, T extends any[], R>(\r\n  f1: (a: A) => R,\r\n  f2: Func<T, A>\r\n): Func<T, R>\r\n\r\n/* three functions */\r\nexport default function compose<A, B, T extends any[], R>(\r\n  f1: (b: B) => R,\r\n  f2: (a: A) => B,\r\n  f3: Func<T, A>\r\n): Func<T, R>\r\n\r\n/* four functions */\r\nexport default function compose<A, B, C, T extends any[], R>(\r\n  f1: (c: C) => R,\r\n  f2: (b: B) => C,\r\n  f3: (a: A) => B,\r\n  f4: Func<T, A>\r\n): Func<T, R>\r\n\r\n/* rest */\r\nexport default function compose<R>(\r\n  f1: (a: any) => R,\r\n  ...funcs: Function[]\r\n): (...args: any[]) => R\r\n\r\nexport default function compose<R>(...funcs: Function[]): (...args: any[]) => R\r\n\r\nexport default function compose(...funcs: Function[]) {\r\n  if (funcs.length === 0) {\r\n    // infer the argument type so it is usable in inference down the line\r\n    return <T>(arg: T) => arg\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0]\r\n  }\r\n\r\n  return funcs.reduce(\r\n    (a, b) =>\r\n      (...args: any) =>\r\n        a(b(...args))\r\n  )\r\n}\r\n","import compose from './compose'\r\nimport { Middleware, MiddlewareAPI } from './types/middleware'\r\nimport { AnyAction } from './types/actions'\r\nimport {\r\n  StoreEnhancer,\r\n  Dispatch,\r\n  PreloadedState,\r\n  StoreEnhancerStoreCreator\r\n} from './types/store'\r\nimport { Reducer } from './types/reducers'\r\n\r\n/**\r\n * Creates a store enhancer that applies middleware to the dispatch method\r\n * of the Redux store. This is handy for a variety of tasks, such as expressing\r\n * asynchronous actions in a concise manner, or logging every action payload.\r\n *\r\n * See `redux-thunk` package as an example of the Redux middleware.\r\n *\r\n * Because middleware is potentially asynchronous, this should be the first\r\n * store enhancer in the composition chain.\r\n *\r\n * Note that each middleware will be given the `dispatch` and `getState` functions\r\n * as named arguments.\r\n *\r\n * @param middlewares The middleware chain to be applied.\r\n * @returns A store enhancer applying the middleware.\r\n *\r\n * @template Ext Dispatch signature added by a middleware.\r\n * @template S The type of the state supported by a middleware.\r\n */\r\nexport default function applyMiddleware(): StoreEnhancer\r\nexport default function applyMiddleware<Ext1, S>(\r\n  middleware1: Middleware<Ext1, S, any>\r\n): StoreEnhancer<{ dispatch: Ext1 }>\r\nexport default function applyMiddleware<Ext1, Ext2, S>(\r\n  middleware1: Middleware<Ext1, S, any>,\r\n  middleware2: Middleware<Ext2, S, any>\r\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 }>\r\nexport default function applyMiddleware<Ext1, Ext2, Ext3, S>(\r\n  middleware1: Middleware<Ext1, S, any>,\r\n  middleware2: Middleware<Ext2, S, any>,\r\n  middleware3: Middleware<Ext3, S, any>\r\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 }>\r\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, S>(\r\n  middleware1: Middleware<Ext1, S, any>,\r\n  middleware2: Middleware<Ext2, S, any>,\r\n  middleware3: Middleware<Ext3, S, any>,\r\n  middleware4: Middleware<Ext4, S, any>\r\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 }>\r\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, Ext5, S>(\r\n  middleware1: Middleware<Ext1, S, any>,\r\n  middleware2: Middleware<Ext2, S, any>,\r\n  middleware3: Middleware<Ext3, S, any>,\r\n  middleware4: Middleware<Ext4, S, any>,\r\n  middleware5: Middleware<Ext5, S, any>\r\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 & Ext5 }>\r\nexport default function applyMiddleware<Ext, S = any>(\r\n  ...middlewares: Middleware<any, S, any>[]\r\n): StoreEnhancer<{ dispatch: Ext }>\r\nexport default function applyMiddleware(\r\n  ...middlewares: Middleware[]\r\n): StoreEnhancer<any> {\r\n  return (createStore: StoreEnhancerStoreCreator) =>\r\n    <S, A extends AnyAction>(\r\n      reducer: Reducer<S, A>,\r\n      preloadedState?: PreloadedState<S>\r\n    ) => {\r\n      const store = createStore(reducer, preloadedState)\r\n      let dispatch: Dispatch = () => {\r\n        throw new Error(\r\n          'Dispatching while constructing your middleware is not allowed. ' +\r\n            'Other middleware would not be applied to this dispatch.'\r\n        )\r\n      }\r\n\r\n      const middlewareAPI: MiddlewareAPI = {\r\n        getState: store.getState,\r\n        dispatch: (action, ...args) => dispatch(action, ...args)\r\n      }\r\n      const chain = middlewares.map(middleware => middleware(middlewareAPI))\r\n      dispatch = compose<typeof dispatch>(...chain)(store.dispatch)\r\n\r\n      return {\r\n        ...store,\r\n        dispatch\r\n      }\r\n    }\r\n}\r\n"],"names":["formatProdErrorMessage","code","$$observable$1","Symbol","observable","randomString","Math","random","toString","substring","split","join","ActionTypes$1","INIT","REPLACE","PROBE_UNKNOWN_ACTION","isPlainObject","obj","proto","Object","getPrototypeOf","createStore","reducer","preloadedState","enhancer","_store","arguments","Error","_formatProdErrorMessage","undefined","_formatProdErrorMessage2","_formatProdErrorMessage3","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","slice","getState","_formatProdErrorMessage4","subscribe","listener","_formatProdErrorMessage5","_formatProdErrorMessage6","isSubscribed","push","_formatProdErrorMessage7","index","indexOf","splice","dispatch","action","_formatProdErrorMessage8","type","_formatProdErrorMessage9","_formatProdErrorMessage10","listeners","i","length","replaceReducer","nextReducer","_formatProdErrorMessage11","ActionTypes","store","_ref","outerSubscribe","observer","_formatProdErrorMessage12","observeState","next","unsubscribe","$$observable","this","combineReducers","reducers","reducerKeys","keys","finalReducers","key","shapeAssertionError","finalReducerKeys","forEach","assertReducerShape","e","state","hasChanged","nextState","previousStateForKey","nextStateForKey","bindActionCreator","actionCreator","_len","args","Array","_key","apply","bindActionCreators","actionCreators","boundActionCreators","compose","funcs","arg","reduce","a","b","applyMiddleware","middlewares","middlewareAPI","_len2","_key2","concat","chain","map","middleware","_objectSpread"],"mappings":"AAOA,SAASA,EAAuBC,GAC9B,MACE,yBAAyBA,EAAgDA,4CAAAA,EAAzE,kFCHJ,IAGAC,EAHsC,WAAA,MACjB,mBAAXC,QAAyBA,OAAOC,YAAe,eADnB,GCChCC,EAAe,WAAA,OACnBC,KAAKC,SAASC,SAAS,IAAIC,UAAU,GAAGC,MAAM,IAAIC,KAAK,MAQzDC,EANoB,CAClBC,KAAI,eAAiCR,IACrCS,QAAO,kBAAoCT,IAC3CU,qBAAsB,WAAA,MAAA,+BAAqCV,MCTrC,SAAAW,EAAcC,GACpC,GAAmB,iBAARA,GAA4B,OAARA,EAAc,OAAO,EAGpD,IADA,IAAIC,EAAQD,EAC4B,OAAjCE,OAAOC,eAAeF,IAC3BA,EAAQC,OAAOC,eAAeF,GAGhC,OAAOC,OAAOC,eAAeH,KAASC,ECgDhB,SAAAG,EAMtBC,EACAC,EACAC,GAAuC,IAAAC,EAEvC,GAC6B,mBAAnBF,GAAqD,mBAAbC,GAC3B,mBAAbA,GAAmD,mBAAjBE,UAAU,GACpD,MAAAC,MAAAC,EAAA,IAaF,GAL8B,mBAAnBL,QAAqD,IAAbC,IACjDA,EAAWD,EACXA,OAAiBM,QAGK,IAAbL,EAA0B,CACnC,GAAwB,mBAAbA,EAAyB,MAAAG,MAAAG,EAAA,IAQpC,OAAON,EAASH,EAATG,CACLF,EACAC,GAIJ,GAAuB,mBAAZD,EAAwB,MAAAK,MAAAI,EAAA,IAQnC,IAAIC,EAAiBV,EACjBW,EAAeV,EACfW,EAA0C,GAC1CC,EAAgBD,EAChBE,GAAgB,EASpB,SAASC,IACHF,IAAkBD,IACpBC,EAAgBD,EAAiBI,SASrC,SAASC,IACP,GAAIH,EAAe,MAAAT,MAAAa,EAAA,IAQnB,OAAOP,EA0BT,SAASQ,EAAUC,GACjB,GAAwB,mBAAbA,EAAyB,MAAAf,MAAAgB,EAAA,IAQpC,GAAIP,EAAe,MAAAT,MAAAiB,EAAA,IASnB,IAAIC,GAAe,EAKnB,OAHAR,IACAF,EAAcW,KAAKJ,GAEZ,WACL,GAAKG,EAAL,CAIA,GAAIT,EAAe,MAAAT,MAAAoB,EAAA,IAOnBF,GAAe,EAEfR,IACA,IAAMW,EAAQb,EAAcc,QAAQP,GACpCP,EAAce,OAAOF,EAAO,GAC5Bd,EAAmB,OA6BvB,SAASiB,EAASC,GAChB,IAAKpC,EAAcoC,GAAS,MAAAzB,MAAA0B,EAAA,IAQ5B,QAA2B,IAAhBD,EAAOE,KAAsB,MAAA3B,MAAA4B,EAAA,IAMxC,GAAInB,EAAe,MAAAT,MAAA6B,EAAA,IAInB,IACEpB,GAAgB,EAChBH,EAAeD,EAAeC,EAAcmB,GACpC,QACRhB,GAAgB,EAIlB,IADA,IAAMqB,EAAavB,EAAmBC,EAC7BuB,EAAI,EAAOD,EAAUE,OAAdD,EAAsBA,IAAK,EAEzChB,EADiBe,EAAUC,MAI7B,OAAON,EAaT,SAASQ,EACPC,GAEA,GAA2B,mBAAhBA,EAA4B,MAAAlC,MAAAmC,EAAA,KAiBvC,OARE9B,EAA8D6B,EAMhEV,EAAS,CAAEG,KAAMS,EAAYjD,UAEtBkD,EAeT,SAAS5D,IAAU,IAAA6D,EACXC,EAAiBzB,EACvB,OAAAwB,EAAA,CASExB,UATF,SASY0B,GACR,GAAwB,iBAAbA,GAAsC,OAAbA,EAAmB,MAAAxC,MAAAyC,EAAA,KAQvD,SAASC,IACoBF,EACJG,MADIH,EAENG,KAAK/B,KAM5B,OAFA8B,IAEO,CAAEE,YADWL,EAAeG,OAIpCG,GAAa,WACZ,OAAOC,MA/BXR,EAuCFd,EAAS,CAAEG,KAAMS,EAAYlD,OAE7B,IAAMmD,IAAKvC,EAAA,CACT0B,SAAUA,EACVV,UAAAA,EACAF,SAAAA,EACAqB,eAAAA,IACCY,GAAepE,EALlBqB,GAOA,OAAOuC,ECnPe,SAAAU,EAAgBC,GAGtC,IAFA,IAAMC,EAAczD,OAAO0D,KAAKF,GAC1BG,EAAmC,GAChCpB,EAAI,EAAOkB,EAAYjB,OAAhBD,EAAwBA,IAAK,CAC3C,IAAMqB,EAAMH,EAAYlB,GAQK,mBAAlBiB,EAASI,KAClBD,EAAcC,GAAOJ,EAASI,IAGlC,IASIC,EATEC,EAAmB9D,OAAO0D,KAAKC,GAUrC,KAxFF,SAA4BH,GAC1BxD,OAAO0D,KAAKF,GAAUO,SAAQ,SAAAH,GAC5B,IAAMzD,EAAUqD,EAASI,GAGzB,QAA4B,IAFPzD,OAAQO,EAAW,CAAEyB,KAAMS,EAAYlD,OAEnB,MAAAc,MAAAC,EAAA,KAUzC,QAGS,IAFAN,OAAQO,EAAW,CACxByB,KAAMS,EAAYhD,yBAEpB,MAAAY,MAAAG,EAAA,QAsEFqD,CAAmBL,GACnB,MAAOM,GACPJ,EAAsBI,EAGxB,OAAO,SACLC,EACAjC,GAEA,QAFiB,IADjBiC,IAAAA,EAAqD,IAGjDL,EACF,MAAMA,EAiBR,IAFA,IAAIM,GAAa,EACXC,EAAyD,GACtD7B,EAAI,EAAOuB,EAAiBtB,OAArBD,EAA6BA,IAAK,CAChD,IAAMqB,EAAME,EAAiBvB,GAEvB8B,EAAsBH,EAAMN,GAC5BU,GAAkBnE,EAFRwD,EAAcC,IAEES,EAAqBpC,GACrD,QAA+B,IAApBqC,EAAiC,MAAA9D,MAAAI,EAAA,KAU5CwD,EAAUR,GAAOU,EACjBH,EAAaA,GAAcG,IAAoBD,EAIjD,OAFAF,EACEA,GAAcL,EAAiBtB,SAAWxC,OAAO0D,KAAKQ,GAAO1B,QAC3C4B,EAAYF,GC9LpC,SAASK,EACPC,EACAxC,GAEA,OAAO,WAAmC,IAAA,IAAAyC,EAAAlE,UAAAiC,OAAXkC,EAAWC,MAAAF,GAAAG,EAAA,EAAAH,EAAAG,EAAAA,IAAXF,EAAWE,GAAArE,UAAAqE,GACxC,OAAO5C,EAASwC,EAAcK,MAAMvB,KAAMoB,KA4ChC,SAAUI,EACtBC,EACA/C,GAEA,GAA8B,mBAAnB+C,EACT,OAAOR,EAAkBQ,EAAgB/C,GAG3C,GAA8B,iBAAnB+C,GAAkD,OAAnBA,EAAyB,MAAAvE,MAAAC,EAAA,KASnE,IAAMuE,EAA+C,GACrD,IAAK,IAAMpB,KAAOmB,EAAgB,CAChC,IAAMP,EAAgBO,EAAenB,GACR,mBAAlBY,IACTQ,EAAoBpB,GAAOW,EAAkBC,EAAexC,IAGhE,OAAOgD,yrBCpCK,SAAUC,IAA4B,IAAA,IAAAR,EAAAlE,UAAAiC,OAAjB0C,EAAiBP,MAAAF,GAAAG,EAAA,EAAAH,EAAAG,EAAAA,IAAjBM,EAAiBN,GAAArE,UAAAqE,GAClD,OAAqB,IAAjBM,EAAM1C,OAED,SAAI2C,GAAJ,OAAeA,GAGH,IAAjBD,EAAM1C,OACD0C,EAAM,GAGRA,EAAME,QACX,SAACC,EAAGC,GAAJ,OACE,WAAA,OACED,EAAEC,EAACT,6BCCG,SAAUU,IACM,IAAA,IAAAd,EAAAlE,UAAAiC,OAAzBgD,EAAyBb,MAAAF,GAAAG,EAAA,EAAAH,EAAAG,EAAAA,IAAzBY,EAAyBZ,GAAArE,UAAAqE,GAE5B,OAAO,SAAC1E,GAAD,OACL,SACEC,EACAC,GAEA,IAAMyC,EAAQ3C,EAAYC,EAASC,GAC/B4B,EAAqB,WAAK,MAAAxB,MAAAC,EAAA,MAOxBgF,EAA+B,CACnCrE,SAAUyB,EAAMzB,SAChBY,SAAU,SAACC,GAAD,IAAA,IAAAyD,EAAAnF,UAAAiC,OAAYkC,EAAZC,MAAAe,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAD,EAAAC,EAAAA,IAAYjB,EAAZiB,EAAA,GAAApF,UAAAoF,GAAA,OAAqB3D,EAAA6C,WAAA,EAAA,CAAS5C,GAAT2D,OAAoBlB,MAE/CmB,EAAQL,EAAYM,KAAI,SAAAC,GAAU,OAAIA,EAAWN,MAGvD,OAFAzD,EAAWiD,EAAAJ,WAAA,EAA4BgB,EAA5BZ,CAAmCpC,EAAMb,UAEpDgE,EAAAA,EAAA,GACKnD,GADL,GAAA,CAEEb,SAAAA"}